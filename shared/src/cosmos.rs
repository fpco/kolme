use cosmwasm_std::{Binary, CosmosMsg, HexBinary};

#[derive(serde::Serialize, serde::Deserialize, Debug, Clone)]
pub struct State {
    pub processor: HexBinary,
    pub executors: Vec<HexBinary>,
    pub needed_executors: u16,
    /// IDs for bridge events.
    pub next_event_id: u32,
    /// IDs for actions generated by Kolme and submitted to this contract.
    pub next_action_id: u32,
}

#[derive(serde::Serialize, serde::Deserialize, Debug, Clone)]
pub struct InstantiateMsg {
    /// Public key for the processor
    pub processor: HexBinary,
    /// Public keys of all executors
    pub executors: Vec<HexBinary>,
    /// How many executors are needed to execute a message
    pub needed_executors: u16,
}

#[derive(serde::Serialize, serde::Deserialize, Debug, Clone)]
pub struct Payload {
    /// Monotonically increasing ID to ensure messages are sent in the correct order.
    /// It must be included in the payload in order to prevent anyone to from re-submitting
    /// a previously successfully executed message but with a different ID.
    pub id: u32,
    pub messages: Vec<CosmosMsg>,
}

#[derive(serde::Serialize, serde::Deserialize, Debug, Clone)]
#[serde(rename_all = "snake_case")]
pub enum ExecuteMsg {
    /// General purpose message for regular interaction.
    ///
    /// You can attach any native funds to this message to perform a deposit for the sending account.
    Regular {
        /// Any new public keys to associate with the sending wallet's account.
        keys: Vec<HexBinary>,
    },
    /// Submit a message signed by the executors and the processor
    ///
    /// Note that this message itself is not permissioned, so that anyone can relay signed messages from the chain.
    Signed {
        /// Signature from the processor
        processor: SignatureWithRecovery,
        /// Signatures from the executors
        executors: Vec<SignatureWithRecovery>,
        /// The raw payload to execute
        ///
        /// This is a JSON encoding of [Payload]. We use a rendered
        /// String here to ensure identical binary representation
        /// so that the signatures will match.
        payload: String,
    },
}

#[derive(serde::Serialize, serde::Deserialize, Debug, Clone)]
#[serde(rename_all = "snake_case")]
pub enum QueryMsg {
    Config {},
    GetEvent { id: u32 },
}

#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum GetEventResp {
    Found { message: Binary },
    NotFound {},
}

#[derive(serde::Serialize, serde::Deserialize, Debug, Clone)]
pub struct SignatureWithRecovery {
    pub recid: u8,
    pub sig: HexBinary,
}
