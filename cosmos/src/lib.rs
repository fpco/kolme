use std::num::TryFromIntError;

use cosmwasm_std::{
    entry_point, from_json, to_json_binary, Api, Binary, Coin, CosmosMsg, Deps, DepsMut, Env,
    Event, HexBinary, MessageInfo, RecoverPubkeyError, Response, Storage,
};
use cw_storage_plus::{Item, Map};
use sha2::{Digest, Sha256};

#[derive(thiserror::Error, Debug)]
pub enum Error {
    #[error(transparent)]
    Cosmwasm {
        #[from]
        source: cosmwasm_std::StdError,
    },
    #[error(transparent)]
    Verification {
        #[from]
        source: cosmwasm_std::VerificationError,
    },
    #[error("No executors provided")]
    NoExecutorsProvided,
    #[error("Too many executors provided")]
    TooManyExecutors(TryFromIntError),
    #[error("Need at least {needed} executors, but only {provided} provided.")]
    InsufficientExecutors { needed: u16, provided: u16 },
    #[error("Incorrect outgoing ID. Expected: {expected}. Received: {received}.")]
    IncorrectOutgoingId { expected: u32, received: u32 },
    #[error("Insufficient executor signatures provided. Needed: {needed}. Provided: {provided}.")]
    InsufficientSignatures { needed: u16, provided: u16 },
    #[error("Invalid signature {sig} with recovery_id {recid}: {source}.")]
    InvalidSignature {
        source: RecoverPubkeyError,
        sig: HexBinary,
        recid: u8,
    },
    #[error("Public key {key} is not part of the executor set.")]
    NonExecutorKey { key: HexBinary },
    #[error("Duplicate public key provided: {key}.")]
    DuplicateKey { key: HexBinary },
    #[error("Processor signature had the wrong public key. Expected key {expected}. Actually signed with {actual}.")]
    NonProcessorKey {
        expected: HexBinary,
        actual: HexBinary,
    },
}

pub type Result<T, E = Error> = std::result::Result<T, E>;

#[derive(serde::Serialize, serde::Deserialize, Debug, Clone)]
#[serde(rename_all = "snake_case")]
struct State {
    processor: HexBinary,
    executors: Vec<HexBinary>,
    needed_executors: u16,
    /// IDs for messages we generate in the contract to be picked up by listeners.
    next_to_kolme_id: u32,
    /// IDs for actions generated by Kolme and submitted to this contract.
    next_from_kolme_id: u32,
}

const STATE: Item<State> = Item::new("s");

/// Outgoing events to be picked up by listeners.
///
/// This is _not_ the way we want to write things! There
/// shouldn't be on-chain storage for events, just logs.
/// However, I'm struggling to make the tx_search endpoints
/// work correctly, so I'm cheating a bit.
const TO_KOLME: Map<u32, Binary> = Map::new("t");

#[derive(serde::Serialize, serde::Deserialize, Debug, Clone)]
#[serde(rename_all = "snake_case")]
pub struct InstantiateMsg {
    /// Public key for the processor
    pub processor: HexBinary,
    /// Public keys of all executors
    pub executors: Vec<HexBinary>,
    /// How many executors are needed to execute a message
    pub needed_executors: u16,
}

#[entry_point]
pub fn instantiate(
    deps: DepsMut,
    _env: Env,
    _info: MessageInfo,
    InstantiateMsg {
        processor,
        executors,
        needed_executors,
    }: InstantiateMsg,
) -> Result<Response> {
    if executors.is_empty() {
        return Err(Error::NoExecutorsProvided);
    }
    let executors_len = u16::try_from(executors.len()).map_err(Error::TooManyExecutors)?;
    if executors_len < needed_executors {
        return Err(Error::InsufficientExecutors {
            needed: needed_executors,
            provided: executors_len,
        });
    }
    let state = State {
        processor,
        executors,
        needed_executors,
        next_to_kolme_id: 0,
        next_from_kolme_id: 0,
    };
    STATE.save(deps.storage, &state)?;
    Ok(Response::new())
}

#[derive(serde::Serialize, serde::Deserialize, Debug, Clone)]
#[serde(rename_all = "snake_case")]
pub enum ExecuteMsg {
    /// General purpose message for regular interaction.
    ///
    /// You can attach any native funds to this message to perform a deposit for the sending account.
    Regular {
        /// Any new public keys to associate with the sending wallet's account.
        keys: Vec<HexBinary>,
    },
    /// Submit a message signed by the executors and the processor
    ///
    /// Note that this message itself is not permissioned, so that anyone can relay signed messages from the chain.
    Signed {
        /// Monotonically increasing ID to ensure messages are sent in the correct order.
        id: u32,
        /// Signature from the processor
        processor: SignatureWithRecovery,
        /// Signatures from the executors
        executors: Vec<SignatureWithRecovery>,
        /// The raw payload to execute
        payload: Binary,
    },
}

#[derive(serde::Serialize, serde::Deserialize, Debug, Clone)]
#[serde(rename_all = "snake_case")]
pub struct SignatureWithRecovery {
    pub recid: u8,
    pub sig: HexBinary,
}

#[entry_point]
pub fn execute(deps: DepsMut, _env: Env, info: MessageInfo, msg: ExecuteMsg) -> Result<Response> {
    match msg {
        ExecuteMsg::Regular { keys } => regular(deps, info, keys),
        ExecuteMsg::Signed {
            id,
            processor,
            executors,
            payload,
        } => signed(deps, info, id, processor, executors, payload),
    }
}

#[derive(serde::Serialize)]
#[serde(rename_all = "snake_case")]
enum Message {
    Regular {
        wallet: String,
        funds: Vec<Coin>,
        keys: Vec<HexBinary>,
    },
    Signed {
        wallet: String,
        outgoing_id: u32,
    },
}

impl Message {
    fn to_response(&self, id: u32, storage: &mut dyn Storage) -> Result<Response> {
        let message = to_json_binary(self)?;
        TO_KOLME.save(storage, id, &message)?;
        Ok(Response::new().add_event(
            Event::new("outgoing")
                .add_attribute("id", id.to_string())
                .add_attribute("message", message.to_string()),
        ))
    }
}

fn regular(deps: DepsMut, info: MessageInfo, keys: Vec<HexBinary>) -> Result<Response> {
    let mut state = STATE.load(deps.storage)?;
    let id = state.next_to_kolme_id;
    state.next_to_kolme_id += 1;
    STATE.save(deps.storage, &state)?;

    Message::Regular {
        wallet: info.sender.into_string(),
        funds: info.funds,
        keys,
    }
    .to_response(id, deps.storage)
}

fn signed(
    deps: DepsMut,
    info: MessageInfo,
    id: u32,
    processor: SignatureWithRecovery,
    executors: Vec<SignatureWithRecovery>,
    payload: Binary,
) -> Result<Response> {
    let mut state = STATE.load(deps.storage)?;
    if id != state.next_from_kolme_id {
        return Err(Error::IncorrectOutgoingId {
            expected: state.next_from_kolme_id,
            received: id,
        });
    }
    state.next_from_kolme_id += 1;
    let incoming_id = state.next_to_kolme_id;
    state.next_to_kolme_id += 1;
    STATE.save(deps.storage, &state)?;

    let executors_len = u16::try_from(executors.len()).map_err(Error::TooManyExecutors)?;
    if executors_len < state.needed_executors {
        return Err(Error::InsufficientSignatures {
            needed: state.needed_executors,
            provided: executors_len,
        });
    }

    let mut hasher = Sha256::new();
    hasher.update(&payload);
    let hash = hasher.finalize();

    let processor = validate_signature(deps.api, &hash, &processor)?;
    if processor != state.processor.as_slice() {
        return Err(Error::NonProcessorKey {
            expected: state.processor,
            actual: HexBinary::from(processor),
        });
    }

    let mut used = vec![];
    for executor in executors {
        let key = HexBinary::from(validate_signature(deps.api, &hash, &executor)?);
        if !state.executors.contains(&key) {
            return Err(Error::NonExecutorKey { key });
        }
        if used.contains(&key) {
            return Err(Error::DuplicateKey { key });
        }
        used.push(key);
    }

    let msgs = from_json::<Vec<CosmosMsg>>(&payload)?;
    Ok(Message::Signed {
        wallet: info.sender.into_string(),
        outgoing_id: id,
    }
    .to_response(incoming_id, deps.storage)?
    .add_messages(msgs))
}

/// Validates the signature and returns the public key of the signer.
fn validate_signature(
    api: &dyn Api,
    hash: &[u8],
    SignatureWithRecovery { recid, sig }: &SignatureWithRecovery,
) -> Result<Vec<u8>> {
    api.secp256k1_recover_pubkey(hash, sig, *recid)
        .map_err(|source| Error::InvalidSignature {
            source,
            sig: sig.clone(),
            recid: *recid,
        })
}

#[derive(serde::Serialize, serde::Deserialize, Debug, Clone)]
#[serde(rename_all = "snake_case")]
pub enum QueryMsg {
    Config {},
    GetToKolmeMessage { id: u32 },
}

#[entry_point]
pub fn query(deps: Deps, _env: Env, msg: QueryMsg) -> Result<Binary> {
    match msg {
        QueryMsg::Config {} => {
            let state = STATE.load(deps.storage)?;
            to_json_binary(&state).map_err(Into::into)
        }
        QueryMsg::GetToKolmeMessage { id } => {
            let resp = match TO_KOLME.may_load(deps.storage, id)? {
                Some(message) => GetToKolmeMessageResp::Found { message },
                None => GetToKolmeMessageResp::NotFound {},
            };
            to_json_binary(&resp).map_err(Into::into)
        }
    }
}

#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum GetToKolmeMessageResp {
    Found { message: Binary },
    NotFound {},
}
