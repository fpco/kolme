use borsh::{BorshDeserialize, BorshSerialize};

use crate::{
    cryptography::{PublicKey, SignatureWithRecovery},
    types::{KeyRegistration, ValidatorSet},
};

pub type Pubkey = [u8; 32];

pub const INITIALIZE_IX: u8 = 0;
pub const REGULAR_IX: u8 = 1;
pub const SIGNED_IX: u8 = 2;

pub const STATE_SEED: &[u8] = b"state";
pub const TOKEN_HOLDER_SEED: &[u8] = b"token_holder";
pub const GIT_REV_SEED: &[u8] = b"git_rev";
pub const UPGRADE_AUTHORITY_SEED: &[u8] = b"upgrade_auth";

#[derive(BorshDeserialize, BorshSerialize, Debug)]
pub struct InitializeIxData {
    pub set: ValidatorSet,
}

#[derive(BorshDeserialize, BorshSerialize, Debug)]
pub struct RegularMsgIxData {
    pub keys: Vec<KeyRegistration>,
    pub transfer_amounts: Vec<u64>,
}

#[derive(BorshDeserialize, BorshSerialize, Debug)]
pub struct SignedMsgIxData {
    /// Signature from the processor
    pub processor: SignatureWithRecovery,
    /// Signatures from the approvers
    pub approvers: Vec<SignatureWithRecovery>,
    /// Base64 encoded string of Borsh serialized [`Payload`]
    pub payload: String,
}

#[derive(BorshDeserialize, BorshSerialize, Debug)]
pub struct Payload {
    /// Monotonically increasing ID to ensure messages are sent in the correct order.
    /// It must be included in the payload in order to prevent anyone to from re-submitting
    /// a previously successfully executed message but with a different ID.
    pub id: u64,
    pub action: SignedAction,
}

#[derive(BorshDeserialize, BorshSerialize, Debug)]
pub enum SignedAction {
    Execute(ExecuteAction),
    SelfReplace {
        /// JSON encoded [`types::SelfReplace`]
        rendered: String,
        signature: SignatureWithRecovery,
    },
    NewSet {
        /// JSON encoded [`types::ValidatorSet`]
        rendered: String,
        approvals: Vec<SignatureWithRecovery>,
    },
}

#[derive(BorshDeserialize, BorshSerialize, Debug)]
pub struct ExecuteAction {
    pub program_id: Pubkey,
    pub accounts: Vec<InstructionAccount>,
    pub instruction_data: Vec<u8>,
    pub signer: Option<SignerAccount>,
}

#[derive(BorshDeserialize, BorshSerialize, Debug)]
pub struct InstructionAccount {
    pub pubkey: Pubkey,
    pub is_writable: bool,
}

#[derive(BorshDeserialize, BorshSerialize, Debug)]
pub struct SignerAccount {
    pub index: u8,
    pub seeds: Vec<Vec<u8>>,
}

#[derive(BorshDeserialize, BorshSerialize, Debug)]
pub struct BridgeMessage {
    pub id: u64,
    pub wallet: Pubkey,
    pub ty: Message,
}

#[derive(BorshDeserialize, BorshSerialize, Debug)]
pub enum Message {
    Regular {
        funds: Vec<Token>,
        keys: Vec<PublicKey>,
    },
    Signed {
        action_id: u64,
    },
}

#[derive(BorshDeserialize, BorshSerialize, Debug)]
pub struct Token {
    pub mint: Pubkey,
    pub amount: u64,
}

#[derive(BorshDeserialize, BorshSerialize, Debug)]
pub struct State {
    pub set: ValidatorSet,
    /// IDs for bridge events.
    pub next_event_id: u64,
    /// IDs for actions generated by Kolme and submitted to this contract.
    pub next_action_id: u64,
}
