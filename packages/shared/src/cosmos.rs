use cosmwasm_std::{Binary, Coin, CosmosMsg};

use crate::{
    cryptography::{PublicKey, SignatureWithRecovery},
    types::{BridgeActionId, BridgeEventId, ValidatorSet, KeyRegistration},
};

#[derive(serde::Serialize, serde::Deserialize, Debug, Clone)]
pub struct State {
    pub set: ValidatorSet,
    /// IDs for bridge events.
    pub next_event_id: BridgeEventId,
    /// IDs for actions generated by Kolme and submitted to this contract.
    pub next_action_id: BridgeActionId,
}

#[derive(serde::Serialize, serde::Deserialize, Debug, Clone)]
pub struct InstantiateMsg {
    pub set: ValidatorSet,
}

#[derive(serde::Serialize, serde::Deserialize, Debug, Clone)]
pub struct PayloadWithId {
    /// Monotonically increasing ID to ensure messages are sent in the correct order.
    /// It must be included in the payload in order to prevent anyone to from re-submitting
    /// a previously successfully executed message but with a different ID.
    pub id: BridgeActionId,
    pub action: CosmosAction,
}

/// An action to be performed based on a submission from the Kolme chain.
#[derive(serde::Serialize, serde::Deserialize, Debug, Clone)]
#[serde(rename_all = "snake_case")]
pub enum CosmosAction {
    Cosmos(Vec<CosmosMsg>),
    SelfReplace {
        /// The rendered version of a [crate::types::SelfReplace]
        rendered: String,
        /// The signature of the validator who is self-replacing.
        signature: SignatureWithRecovery,
    },
    NewSet {
        /// The rendered version of a [ValidatorSet].
        rendered: String,
        approvals: Vec<SignatureWithRecovery>,
    },
}

#[derive(serde::Serialize, serde::Deserialize, Debug, Clone)]
#[serde(rename_all = "snake_case")]
pub enum ExecuteMsg {
    /// General purpose message for regular interaction.
    ///
    /// You can attach any native funds to this message to perform a deposit for the sending account.
    Regular {
        /// Any new public keys to associate with the sending wallet's account.
        keys: Vec<KeyRegistration>,
    },
    /// Submit a message signed by the approvers and the processor
    ///
    /// Note that this message itself is not permissioned, so that anyone can relay signed messages from the chain.
    Signed {
        /// Signature from the processor
        processor: SignatureWithRecovery,
        /// Signatures from the approvers
        approvers: Vec<SignatureWithRecovery>,
        /// The raw payload to execute
        ///
        /// This is a JSON encoding of [PayloadWithId]. We use a rendered
        /// String here to ensure identical binary representation
        /// so that the signatures will match.
        payload: String,
    },
}

#[derive(serde::Serialize, serde::Deserialize, Debug, Clone)]
#[serde(rename_all = "snake_case")]
pub enum QueryMsg {
    Config {},
    GetEvent { id: BridgeEventId },
}

#[derive(serde::Serialize, serde::Deserialize, Debug, Clone)]
#[serde(rename_all = "snake_case")]
pub struct MigrateMsg {}

#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum GetEventResp {
    Found { message: Binary },
    NotFound {},
}

#[derive(serde::Serialize, serde::Deserialize, Clone, Debug)]
#[serde(rename_all = "snake_case")]
pub enum BridgeEventMessage {
    Regular {
        wallet: String,
        funds: Vec<Coin>,
        keys: Vec<PublicKey>,
    },
    Signed {
        wallet: String,
        action_id: BridgeActionId,
    },
}
