use std::collections::BTreeSet;

use cosmwasm_std::{Binary, Coin, CosmosMsg};

use crate::{
    cryptography::{PublicKey, SignatureWithRecovery},
    types::{BridgeActionId, BridgeEventId},
};

#[cfg(feature = "realcryptography")]
use crate::cryptography::{SecretKey, SecretKeyError};

#[derive(serde::Serialize, serde::Deserialize, Debug, Clone)]
pub struct State {
    pub processor: PublicKey,
    pub approvers: BTreeSet<PublicKey>,
    pub needed_approvers: u16,
    /// IDs for bridge events.
    pub next_event_id: BridgeEventId,
    /// IDs for actions generated by Kolme and submitted to this contract.
    pub next_action_id: BridgeActionId,
}

#[derive(serde::Serialize, serde::Deserialize, Debug, Clone)]
pub struct InstantiateMsg {
    /// Public key for the processor
    pub processor: PublicKey,
    /// Public keys of all approvers
    pub approvers: BTreeSet<PublicKey>,
    /// How many approvers are needed to approve a bridge action
    pub needed_approvers: u16,
}

#[derive(serde::Serialize, serde::Deserialize, Debug, Clone)]
pub struct Payload {
    /// Monotonically increasing ID to ensure messages are sent in the correct order.
    /// It must be included in the payload in order to prevent anyone to from re-submitting
    /// a previously successfully executed message but with a different ID.
    pub id: BridgeActionId,
    pub messages: Vec<CosmosMsg>,
}

#[derive(serde::Serialize, serde::Deserialize, Debug, Clone)]
#[serde(rename_all = "snake_case")]
pub enum ExecuteMsg {
    /// General purpose message for regular interaction.
    ///
    /// You can attach any native funds to this message to perform a deposit for the sending account.
    Regular {
        /// Any new public keys to associate with the sending wallet's account.
        keys: Vec<KeyRegistration>,
    },
    /// Submit a message signed by the approvers and the processor
    ///
    /// Note that this message itself is not permissioned, so that anyone can relay signed messages from the chain.
    Signed {
        /// Signature from the processor
        processor: SignatureWithRecovery,
        /// Signatures from the approvers
        approvers: Vec<SignatureWithRecovery>,
        /// The raw payload to execute
        ///
        /// This is a JSON encoding of [Payload]. We use a rendered
        /// String here to ensure identical binary representation
        /// so that the signatures will match.
        payload: String,
    },
}

#[derive(serde::Serialize, serde::Deserialize, Debug, Clone)]
pub struct KeyRegistration {
    pub signature: SignatureWithRecovery,
    pub key: PublicKey,
}

#[derive(serde::Serialize, serde::Deserialize, Debug, Clone)]
#[serde(rename_all = "snake_case")]
pub enum QueryMsg {
    Config {},
    GetEvent { id: BridgeEventId },
}

#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum GetEventResp {
    Found { message: Binary },
    NotFound {},
}

#[derive(serde::Serialize, serde::Deserialize, Clone, Debug)]
#[serde(rename_all = "snake_case")]
pub enum BridgeEventMessage {
    Regular {
        wallet: String,
        funds: Vec<Coin>,
        keys: Vec<PublicKey>,
    },
    Signed {
        wallet: String,
        action_id: BridgeActionId,
    },
}

#[cfg(feature = "realcryptography")]
impl KeyRegistration {
    pub fn new(address: &str, key: &SecretKey) -> Result<Self, SecretKeyError> {
        Ok(Self {
            signature: key.sign_recoverable(address)?,
            key: key.public_key(),
        })
    }
}
