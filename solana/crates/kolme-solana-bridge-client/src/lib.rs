#[cfg(feature = "client")]
mod client;

#[cfg(feature = "client")]
pub use client::*;

#[cfg(feature = "client")]
pub use solana_pubkey as pubkey;

#[cfg(feature = "client")]
pub use solana_keypair as keypair;

use borsh::{BorshDeserialize, BorshSerialize};

pub type Pubkey = [u8; 32];

pub const INITIALIZE_IX: u8 = 0;
pub const REGULAR_IX: u8 = 1;
pub const SIGNED_IX: u8 = 2;

pub const TOKEN_HOLDER_SEED: &[u8] = b"token_holder";

#[derive(BorshDeserialize, BorshSerialize, Clone, Eq, PartialEq)]
pub struct Secp256k1Pubkey(pub [u8; Self::LEN]);

#[derive(BorshDeserialize, BorshSerialize, Clone, Eq, PartialEq)]
pub struct Secp256k1PubkeyCompressed(pub [u8; Self::LEN]);

#[derive(BorshDeserialize, BorshSerialize, Clone, Eq, PartialEq)]
pub struct Secp256k1Signature(pub [u8; Self::LEN]);

#[derive(BorshDeserialize, BorshSerialize)]
pub struct InitializeIxData {
    pub needed_executors: u8,
    pub processor: Secp256k1PubkeyCompressed,
    pub executors: Vec<Secp256k1PubkeyCompressed>,
}

#[derive(BorshDeserialize, BorshSerialize)]
pub struct RegularMsgIxData {
    pub keys: Vec<Secp256k1PubkeyCompressed>,
    pub transfer_amounts: Vec<u64>
}

#[derive(BorshDeserialize, BorshSerialize)]
pub struct SignedMsgIxData {
    /// Signature from the processor
    pub processor: Signature,
    /// Signatures from the executors
    pub executors: Vec<Signature>,
    /// The raw payload to execute
    pub payload: Vec<u8>,
}

#[derive(BorshDeserialize, BorshSerialize)]
pub struct Signature {
    pub signature: Secp256k1Signature,
    pub recovery_id: u8,
}

#[derive(BorshDeserialize, BorshSerialize)]
pub struct Payload {
    /// Monotonically increasing ID to ensure messages are sent in the correct order.
    /// It must be included in the payload in order to prevent anyone to from re-submitting
    /// a previously successfully executed message but with a different ID.
    pub id: u64,
    pub program_id: Pubkey,
    pub accounts: Vec<InstructionAccount>,
    pub instruction_data: Vec<u8>,
    pub signer: Option<SignerAccount>
}

#[derive(BorshDeserialize, BorshSerialize)]
pub struct InstructionAccount {
    pub pubkey: Pubkey,
    pub is_writable: bool,
}

#[derive(BorshDeserialize, BorshSerialize)]
pub struct SignerAccount {
    pub index: u8,
    pub seeds: Vec<Vec<u8>>,
}

#[derive(BorshDeserialize, BorshSerialize)]
pub struct BridgeMessage {
    pub id: u64,
    pub wallet: Pubkey,
    pub ty: Message
}

#[derive(BorshDeserialize, BorshSerialize)]
pub enum Message {
    Regular {
        funds: Vec<Token>,
        keys: Vec<Secp256k1PubkeyCompressed>,
    },
    Signed {
        action_id: u64,
    },
}

#[derive(BorshDeserialize, BorshSerialize)]
pub struct Token {
    pub mint: Pubkey,
    pub amount: u64
}

#[derive(BorshDeserialize, BorshSerialize)]
pub struct State {
    pub processor: Secp256k1PubkeyCompressed,
    pub executors: Vec<Secp256k1PubkeyCompressed>,
    pub needed_executors: u8,
    /// IDs for bridge events.
    pub next_event_id: u64,
    /// IDs for actions generated by Kolme and submitted to this contract.
    pub next_action_id: u64,
}

impl Secp256k1Pubkey {
    pub const LEN: usize = 64;
}

impl Secp256k1PubkeyCompressed {
    pub const LEN: usize = 33;
}

impl Secp256k1Signature {
    pub const LEN: usize = 64;

    // Ported from: https://github.com/cryspen/hacl-packages/blob/05c3d8fb321ed65e3db3a6a8b853019e86fb40a2/src/msvc/Hacl_K256_ECDSA.c#L1772
    /// Returns `true` if S is low-S normalized and `false` otherwise.
    pub fn is_normalized(&self) -> bool {
        // Signature consists of R and S components respectively, each 32 bytes big.
        const OFFSET: usize = 32;

        let mut a: [u64; 4] = [0; 4];

        for i in 0..4 {
            let offset = OFFSET + (4 - i - 1) * 8;
            let bytes: [u8; 8] = self.0.as_slice()[offset..offset + 8].try_into().unwrap();
            a[i] = u64::from_be_bytes(bytes);
        }

        let [a0, a1, a2, a3] = a;

        if a0 == 0 && a1 == 0 && a2 == 0 && a3 == 0 {
            return false;
        }

        let is_lt_q_b = if a3 < 0xffffffffffffffff {
            true
        } else if a2 < 0xfffffffffffffffe {
            true
        } else if a2 > 0xfffffffffffffffe {
            false
        } else if a1 < 0xbaaedce6af48a03b {
            true
        } else if a1 > 0xbaaedce6af48a03b {
            false
        } else {
            a0 < 0xbfd25e8cd0364141
        };

        let is_s_lt_q_halved = if a3 < 0x7fffffffffffffff {
            true
        } else if a3 > 0x7fffffffffffffff {
            false
        } else if a2 < 0xffffffffffffffff {
            true
        } else if a1 < 0x5d576e7357a4501d {
            true
        } else if a1 > 0x5d576e7357a4501d {
            false
        } else {
            a0 <= 0xdfe92f46681b20a0
        };

        is_lt_q_b && is_s_lt_q_halved
    }
}

impl Secp256k1Pubkey {
    /// Returns `0x02` if y-coordinate is even and `0x03` if odd.
    pub fn y_parity(&self) -> u8 {
        if self.0[Self::LEN - 1] & 1 == 1 {
            0x03
        } else {
            0x02
        }
    }

    pub fn to_sec1_bytes(&self) -> Secp256k1PubkeyCompressed {
        let mut res = [0u8; 33];
        res[0] = self.y_parity();
        res[1..].copy_from_slice(&self.0.as_slice()[..32]);

        Secp256k1PubkeyCompressed(res)
    }
}
